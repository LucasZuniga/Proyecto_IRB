\documentclass[spanish, letterpaper, journal]{IEEEtran}
\usepackage{amsmath,amsfonts}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{url}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{fontspec}
\setmonofont{DejaVu Sans Mono}

\begin{document}

\title{Diseño y Desarrollo de Robots Educativos para Introducción a la Robótica mediante Fútbol de Robots}

\author{Allende, S., Lorca, S., Reyes, B., Román, C., Zúñiga, L.}

\maketitle


\begin{abstract}
    Este trabajo presenta el diseño y desarrollo de robots educativos enfocados en la enseñanza introductoria de robótica, utilizando el fútbol como plataforma experimental. El proyecto abarca desde la definición de las dimensiones físicas del robot hasta la implementación del circuito de control, la estructura mecánica y la programación inicial. Se propone un diseño compacto (10x10 cm) con tres motores de corriente continua para movimiento y un solenoide para el disparo del balón. Como innovación, se incorpora un rodillo de control de balón que mejora significativamente la precisión y maniobrabilidad en comparación con la antigua pinza utilizada en versiones previas.
\end{abstract}


%\begin{IEEEkeywords}
%Robótica educativa, fútbol de robots, diseño mecatrónico, control de %motores, aprendizaje activo.
%\end{IEEEkeywords}

\section{Introducción}
\IEEEPARstart{E}{l} presente trabajo tiene como objetivo desarrollar una plataforma educativa que facilite la introducción a la robótica mediante robots futbolistas. Como se ha establecido en estudios previos~\cite{robocup}, los entornos competitivos como RoboCupJunior aumentan significativamente la motivación de los estudiantes y facilitan la adquisición de conceptos STEM en comparación con métodos tradicionales.

\subsection{Objetivos del proyecto}
\begin{itemize}
    \item Diseñar un robot funcional dentro de un área de 10x10 cm.
    \item Desarrollar un sistema de control capaz de manipular un balón con precisión mediante un rodillo.
    \item Implementar una estructura robusta y ligera para facilitar el movimiento.
    \item Introducir conceptos de control, sensado, comunicación y visión computacional en un entorno educativo.
\end{itemize}

\section{Análisis Inicial y Restricciones de Diseño}
Antes de iniciar el desarrollo, se evaluaron las dimensiones del laboratorio y las limitaciones de los materiales disponibles. Se determinó que una base de 10x10 cm ofrecía un equilibrio adecuado entre estabilidad, maniobrabilidad y espacio para componentes electrónicos.

\subsection{Requerimientos de diseño}
\begin{itemize}
    \item Tamaño máximo: 10x10 cm.
    \item Peso objetivo: [COMPLETAR].
    \item Componentes principales: Raspberry Pi Pico 2 W, 2 motores DC N20, 1 solenoide, 1 rodillo de control de balón.
    \item Fuente de energía: [COMPLETAR].
    \item Comunicación: WiFi (preferente) y Bluetooth para interacción con múltiples dispositivos.
    \item Capacidades funcionales:
          \begin{itemize}
              \item Mantener posesión del balón mediante rodillo de control.
              \item Realizar golpeo del balón mediante solenoide.
              \item Desplazamiento omnidireccional sobre la cancha.
              \item Control simultáneo desde múltiples dispositivos.
          \end{itemize}
\end{itemize}

\section{Diseño Mecánico}
El diseño mecánico busca un equilibrio entre simplicidad, resistencia y precisión en el control del balón.

\subsection{Estructura y materiales}
El chasis se fabrica en material liviano (por ejemplo, acrílico o PLA impreso en 3D), con soporte modular para motores, rodillo y electrónica. La disposición de componentes se optimiza para mantener el centro de masa bajo y facilitar el mantenimiento.

\subsection{Sistema de locomoción}

El robot consta de dos ruedas motorizadas junto con un apoyo tipo bola, el cual proporciona un tercer punto de apoyo sin interferir en el movimiento. Las ruedas motorizadas se encuentran en la parte delantera del robot, una a cada lado. Los motores utilizados son motores DC N20 con una caja reductora de relación 1:100.

Esta disposición permite al robot realizar movimientos lineales y giros sobre su eje al aplicar un control diferencial sobre ambas ruedas. La combinación de ambos movimientos permite al robot desplazarse de manera ágil a lo largo de toda la cancha, manteniendo el control del balón durante la maniobra.

\subsection{Sistema de control de balón}
Se reemplaza la antigua pinza mecánica por un rodillo frontal activo que permite atrapar, retener y mantener la posesión del balón de manera continua. El rodillo gira constantemente atrayendo el balón hacia el robot y manteniéndolo en contacto, lo que facilita el control dinámico durante el desplazamiento.

La implementación de un mecanismo de dribbling activo permite aplicar efecto de retroceso (backspin) al balón, creando un efecto de ``succión'' que mejora la retención durante aceleraciones y giros, una técnica ampliamente validada en la Small Size League~\cite{dribble}. Esta solución presenta ventajas significativas sobre la pinza anterior: permite mantener posesión del balón mientras el robot se desplaza, aumenta la capacidad de maniobra en espacios reducidos, y proporciona mayor estabilidad al sistema durante movimientos complejos. El diseño del rodillo asegura que el balón permanezca bajo control incluso durante giros cerrados o cambios bruscos de dirección.

\subsection{Mecanismo de disparo}
El disparo del balón se realiza mediante un solenoide lineal que proporciona una fuerza de impacto controlada y repetible. Al activarse, el solenoide empuja un émbolo que golpea el balón con una fuerza suficiente para enviarlo a través de la cancha.

El diseño incluye amortiguación para proteger los componentes electrónicos de vibraciones y prolongar la vida útil del actuador. La temporización del disparo se controla mediante el microcontrolador, permitiendo ajustar la intensidad del golpeo según la estrategia de juego.

\section{Diseño Electrónico}
El sistema electrónico está basado en un microcontrolador Raspberry Pi Pico 2 W, elegido por su bajo costo, capacidad de procesamiento dual-core, conectividad inalámbrica integrada y facilidad de programación. La arquitectura electrónica se diseñó considerando eficiencia energética, modularidad y robustez ante condiciones de operación exigentes.

\subsection{Arquitectura del Sistema}
La arquitectura electrónica del robot se organiza en cuatro subsistemas principales que interactúan de manera coordinada: la unidad de procesamiento central (MCU), la red de distribución de energía, la interfaz de control de motores dual, y el circuito de actuación del solenoide. La Fig.~\ref{fig_block_diagram} presenta un diagrama de bloques de alto nivel que ilustra el flujo de datos y potencia entre estos subsistemas.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=\linewidth]{figs/block_diagram.pdf}
    \caption{Diagrama de bloques de la arquitectura electrónica. Las líneas rojas indican flujo de potencia y las azules representan flujo de datos y señales de control.}
    \label{fig_block_diagram}
\end{figure}

Como se observa en el diagrama, el sistema recibe alimentación de una batería LiPo de 7.4V que se distribuye a través de una red regulada hacia los diferentes subsistemas. El MCU coordina todas las operaciones, procesando comandos inalámbricos (WiFi/Bluetooth), ejecutando algoritmos de control y generando señales de actuación. Los motores DC reciben señales PWM moduladas a través del driver TB6612FNG, mientras que el solenoide se activa mediante un circuito de conmutación basado en transistor TIP102. La retroalimentación de los encoders magnéticos cierra el lazo de control, permitiendo un seguimiento preciso de las velocidades de las ruedas.

\subsection{Unidad de Procesamiento Central (MCU)}
El Raspberry Pi Pico 2 W constituye el cerebro del sistema, actuando como coordinador central de todas las operaciones del robot. La selección de este microcontrolador se fundamenta en múltiples criterios técnicos y pedagógicos que lo hacen ideal para una plataforma educativa de robótica.

\textbf{Justificación de la selección:}

\textit{Facilidad de programación y versatilidad de lenguajes:}
Una de las principales ventajas del Raspberry Pi Pico 2 W es su compatibilidad con múltiples entornos de programación, específicamente MicroPython y C/C++. Esta característica resulta fundamental para el curso donde será implementado, ya que permite:
\begin{itemize}
    \item \textit{MicroPython}: Ofrece una curva de aprendizaje suave para estudiantes sin experiencia previa en programación de microcontroladores. La sintaxis intuitiva y el desarrollo interactivo mediante REPL facilitan la experimentación rápida y la depuración de código.
    \item \textit{C/C++}: Proporciona acceso a bajo nivel del hardware para estudiantes avanzados que requieren optimización de rendimiento o funcionalidades específicas. Permite introducir conceptos de programación de sistemas embebidos y gestión eficiente de recursos.
\end{itemize}

Esta dualidad de lenguajes permite adaptar el nivel de complejidad según el progreso de los estudiantes, desde programación de alto nivel hasta control de hardware a bajo nivel, sin cambiar de plataforma.

\textit{Arquitectura dual-core para procesamiento paralelo:}
El procesador dual-core ARM Cortex-M33 a 133 MHz representa una ventaja arquitectónica significativa. Como se detalla en la sección de software, esta característica permite:
\begin{itemize}
    \item Dedicar un núcleo (Core 0) exclusivamente a tareas de \textbf{comunicación inalámbrica}, gestionando la recepción y envío de paquetes UDP sin interrumpir otras operaciones.
    \item Asignar el segundo núcleo (Core 1) al \textbf{control en tiempo real} del robot, ejecutando algoritmos PID, lectura de sensores y generación de señales de actuación.
    \item Garantizar determinismo temporal en el lazo de control, crítico para la estabilidad del sistema.
\end{itemize}

Esta separación arquitectónica elimina conflictos de recursos y asegura que las comunicaciones de red no introduzcan latencias variables en el control del robot.

\textit{Capacidades GPIO flexibles:}
El microcontrolador ofrece 26 pines GPIO programables que soportan múltiples protocolos y funciones:
\begin{itemize}
    \item \textit{PWM (Pulse Width Modulation)}: 16 canales PWM independientes para control preciso de velocidad de motores y modulación del solenoide.
    \item \textit{GPIO digital}: Señales de dirección para drivers de motores, activación del solenoide y lectura de encoders.
    \item \textit{Protocolos de comunicación}: I2C, SPI y UART disponibles para expansión futura con sensores adicionales.
    \item \textit{ADC}: Conversores analógico-digital para monitoreo de voltaje de batería y otros parámetros analógicos.
\end{itemize}

\textbf{Interfaz con controladores de motores:}
El MCU se comunica con el driver TB6612FNG mediante una interfaz mixta digital-PWM optimizada para control diferencial:
\begin{itemize}
    \item \textit{Control de velocidad}: Se generan señales PWM independientes para cada motor (pines PWM\_A y PWM\_B), permitiendo ajustar la velocidad de manera continua desde 0 hasta el máximo. La frecuencia PWM se configura típicamente entre 20-40 kHz para minimizar ruido audible y mejorar la eficiencia del driver.
    \item \textit{Control de dirección}: Cada motor requiere dos señales digitales (IN1/IN2 para motor A, IN3/IN4 para motor B) que determinan el sentido de rotación. La combinación de estas señales permite cuatro estados por motor: avance, retroceso, frenado activo y rueda libre.
    \item \textit{Habilitación}: Señales de habilitación (STBY) controlan el estado activo/standby del driver, permitiendo gestión de energía cuando el robot está inactivo.
\end{itemize}

Esta configuración proporciona control completo y preciso de ambos motores, habilitando maniobras complejas como giro en el lugar, trayectorias curvas y control de velocidad independiente para compensación de desbalances mecánicos.

\textbf{Especificaciones técnicas principales:}
\begin{itemize}
    \item Procesador dual-core ARM Cortex-M33 a 133 MHz.
    \item 264 KB de SRAM y 2 MB de memoria flash.
    \item WiFi 802.11n (2.4 GHz) y Bluetooth 5.2 integrados con antena cerámica.
    \item 26 pines GPIO multifunción con soporte para PWM, I2C, SPI, UART, ADC.
    \item Bajo consumo energético: $<$ 1 mA en modo dormido, permitiendo implementar estrategias de ahorro de energía.
    \item Amplio rango de voltaje de operación (1.8V-5.5V) con regulador interno de 3.3V.
    \item Interfaz USB 1.1 para programación y depuración.
\end{itemize}

\subsection{Circuitos de Accionamiento y Control}

\textbf{Driver de Motores (TB6612FNG):}
El TB6612FNG es un controlador de motores DC dual que permite controlar dos motores de manera independiente. Sus características relevantes son:
\begin{itemize}
    \item Corriente continua de 1.2A por canal (3.2A pico).
    \item Control de dirección mediante señales digitales (IN1, IN2).
    \item Control de velocidad mediante modulación PWM.
    \item Modo de frenado activo (cortocircuito de terminales del motor).
    \item Protección térmica y contra sobrecorriente integradas.
\end{itemize}

El MCU genera tres señales por motor: dos señales de dirección y una señal PWM para controlar la velocidad. Esta configuración permite control diferencial preciso para la locomoción del robot.

\textbf{Circuito de Actuación del Solenoide (TIP102):}
El solenoide lineal requiere corrientes superiores a las que el MCU puede suministrar directamente. Se implementa un circuito de conmutación basado en el transistor Darlington TIP102:
\begin{itemize}
    \item Capacidad de corriente: hasta 8A continua.
    \item Tensión de operación: hasta 100V.
    \item Ganancia de corriente elevada ($h_{FE} > 1000$), permitiendo activación con señales de bajo nivel desde el MCU.
    \item Diodo de protección en paralelo con el solenoide para suprimir picos de voltaje inductivo.
\end{itemize}

Una señal digital del MCU controla la base del transistor, permitiendo la conmutación rápida del solenoide para efectuar el disparo del balón.

\subsection{Gestión de Energía}
La gestión eficiente de la energía es crítica para maximizar la autonomía y proteger los componentes del sistema.

\textbf{Fuente de Alimentación:}
Se utiliza una batería LiPo de 2 celdas (7.4V nominal, 8.4V cargada completamente) con capacidad adecuada para proporcionar [COMPLETAR] mAh. Las baterías LiPo ofrecen alta densidad energética y capacidad de descarga, esenciales para alimentar los motores y el solenoide.

\textbf{Red de Distribución de Voltajes:}
El sistema requiere múltiples niveles de voltaje:
\begin{itemize}
    \item \textit{7.4V directo}: Alimentación del solenoide para maximizar la fuerza de disparo.
    \item \textit{5V regulado}: Alimentación de la lógica del TB6612FNG y motores DC.
    \item \textit{3.3V regulado}: Alimentación del Raspberry Pi Pico 2 W y lógica digital.
\end{itemize}

Para esta primera iteración del diseño, se emplean reguladores lineales simples para minimizar complejidad. Se distribuyen capacitores de desacople cerca de cada IC para estabilizar la alimentación.

\textbf{Protecciones:}
\begin{itemize}
    \item Diodo de protección de polaridad inversa en la línea principal.
    \item Diodo de protección (flyback) en paralelo con el solenoide para suprimir picos de voltaje inductivo.
    \item Switch mecánico para activación manual del solenoide en esta primera iteración.
\end{itemize}

Estas consideraciones de gestión de energía más avanzadas (reguladores conmutados, fusibles resetables, monitoreo dinámico de voltaje) se incorporarán en la segunda iteración del diseño electrónico, una vez validada la funcionalidad del sistema.

\section{Desarrollo de Software}
Dado que para el funcionamiento del proyecto debe haber un servidor y uno o más clientes, la programación se dividió en tres módulos: base/, extras/ y player/.

{\small\ttfamily
\begin{verbatim} 
software/
├── base/
│   ├── aruco_detector2.py
│   ├── servidor.py
│   └── extras/
├── player/
│   ├── control_lib.py
│   ├── WiFi.py
│   ├── main.py
│   └── extras/
└── extras/

\end{verbatim}
}

\subsection{base/}
Tal como lo indica su nombre, este módulo contiene la lógica necesaria para el correcto funcionamiento de la estacion base encargada de transmitirle los comandos al robot. Dentro de este módulo se encuentan dos archivos principales, \textit{aruco\_detector2.py} y \textit{servidor.py}.

\vspace{0.3cm}
\subsubsection{aruco\_detector2.py}
Para obtener la posición y orientación de los distintos robots en la cancha, se utilizó un sistema de \textit{ArUco markers}, dado que se trata de un método robusto que permite detectar varios marcadores a la vez con un id especifico para cada uno.

En este archivo se encuentra un diccionario con las distintas familias de marcadores, además de una clase ArUco\_Marker(), que permitirá guardar información sobre cada uno de los marcadores y dibujar en el frame de la camara información relevante para ser vista por el usuario. También se encuentra una clase ArUco\_Detector(), la cual contine ll lógica necesaria para la detección de los marcadores, ademas de guardar los marcadores detectados en una lista.

Librerias utilizadas:
\begin{itemize}
    \item cv2
    \item math
    \item numpy
\end{itemize}

\vspace{0.3cm}
\subsubsection{servidor.py}
Este es el archivo principal que se deberá correr en el computador base, para la comunicación con los robots a controlar, en este programa se aceptan las conecciones de los robots, junto con estar constantemente enviando tanto las velocidades de los motores, como el encendido y apagado del rodillo y solenoide.

El funcionamiento de código se basa en el uso de dos threads, uno que recibe las velocidades (actualmente enviadas desde el teclado, para control manual) y otro que envía las velocidades haciendo uso del protocolo UDP. La sincronización de las velocidades recibidas y enviadas se realiza mediante una variable global.

Librerias utilizadas:
\begin{itemize}
    \item socket
    \item threading
    \item time
    \item keyboard
\end{itemize}

\vspace{0.3cm}
Junto a los dos archivos principales, se tiene una carpeta llamada extras, en la cual se encuentran archivos que pueden ser utiles pero que su uso no es requerido en el loop principal del proyecto, dentro de estos archivos se encuentra uno que permite la generación de \textit{ArUco markers} entregandole la familia de marcadores y el id deseado.


\subsection{player/}
Este módulo contiene el programa que se estará ejecutando en cada uno de los robots, es decir, los códigos que se deberán cargar directamente al microcontrolador del robot. Dentro de esta carpeta se encuentran tres archivos principales, \textit{control\_lib.py}, \textit{WiFi.py} y \textit{main.py}.

\vspace{0.3cm}
\subsubsection{control\_lib.py}
Para obteer un código más légible y modular, se creo este archivo con el fin de que contenga las funciones relacionadas al control del robot. Dentro de estas funciones se encuentran la detección de los flancos de subida y de bajada de la señal recibida de los encoders, esto con el fin de obtener las rotaciones y realizar la lectura de la velocidad real de las ruedas. Además se encuentran las funciones encargadas de enviar las velocidades a los motores y al rodillo.

No se utilizaron librerias externas en este archivo.

\vspace{0.3cm}
\subsubsection{WiFi.py}
Tal como se indicó al iniccio del documento, al coneccion de cada robot con su respectiva base se realizó mediante WiFi, para permitir la conección de una base con multiples robots. Por lo anterior, en ese archivo se encuentran las funciones necesarias para iniciar una conección del robot a una red WiFi.

librerias utilizadas:
\begin{itemize}
    \item machine
    \item network
    \item rp2
    \item uasyncio
\end{itemize}

\vspace{0.3cm}
\subsubsection{main.py}

Este archivo corresponde al código principal del robot, encargado de gestionar la conexión WiFi, la comunicación con el servidor central y el control en lazo cerrado de los motores. Es el núcleo operativo del sistema, ya que coordina tanto la recepción de comandos como la ejecución de los movimientos.

El programa inicializa los pines de la Raspberry Pi Pico W, incluyendo LEDs de estado, drivers de motor, encoders y el solenoide. También configura la frecuencia de los PWM y variables globales utilizadas para el control.

A través de la función \texttt{iniciar\_cliente()}, el robot establece una conexión UDP con el servidor, envía su identificación y recibe continuamente las velocidades de referencia para ambos motores, además del estado del solenoide y del rodillo. Estos comandos se traducen en acciones sobre el hardware mediante funciones de la librería \texttt{control\_lib}.

En paralelo, mediante un hilo independiente, la función \texttt{close\_loop()} ejecuta el control de velocidad en lazo cerrado. Utilizando las lecturas de los encoders, calcula la velocidad de cada motor, estima la variación de pulsos y aplica un controlador PID para ajustar el \textit{duty cycle} del PWM. De esta forma, el robot puede seguir con precisión las velocidades indicadas por el servidor.

Finalmente, el archivo coordina la conexión WiFi mediante tareas asincrónicas que aseguran mantener el enlace activo y reactivo, mientras supervisa la comunicación y el control en tiempo real.

Librerias utilizadas:
\begin{itemize}
    \item machine
    \item network
    \item rp2
    \item socket
    \item \_thread
    \item time
    \item uasyncio
    \item control\_lib (propia)
    \item WiFi (propia)
\end{itemize}


\subsection{extras/}

En esta carpeta se incluyen diversos archivos complementarios que pueden resultar útiles para la programación del robot más allá del marco principal del proyecto. Entre ellos se encuentran dos simuladores que permiten realizar pruebas sin depender del robot físico.

El primer simulador corresponde a una base sencilla pensada para servir como punto de partida para desarrollos posteriores. En él es posible controlar dos robots utilizando únicamente el teclado: uno mediante las teclas \texttt{WASD} y el otro con \texttt{IJKL}. Su propósito principal es brindar un entorno simple donde se puedan realizar pruebas rápidas o construir nuevas funcionalidades.

El segundo simulador está orientado específicamente a la evaluación de comportamientos autónomos. En este caso, uno de los robots se controla nuevamente con las teclas \texttt{WASD}, mientras que el robot del equipo contrario recibe sus comandos desde una rutina autónoma definida por el usuario. Esto permite probar estrategias, algoritmos de movimiento y lógica de decisión sin la necesidad de utilizar el hardware real, ofreciendo una herramienta valiosa para experimentar y depurar el código de autonomía.

\subsection{Pruebas realizadas}
[COMPLETAR]

\subsection{Limitaciones observadas}
[COMPLETAR]

\section{Conclusiones y Trabajo Futuro}
El diseño presentado demuestra que es posible construir una plataforma educativa robusta, modular y escalable. La sustitución de la pinza por un rodillo mejoró considerablemente la manipulación del balón.
Como trabajo futuro, se planea incorporar algoritmos de visión artificial, control autónomo y estrategias cooperativas entre múltiples robots.

\section*{Disponibilidad de Material}
Todo el material relacionado con este proyecto, incluyendo diseños mecánicos (archivos CAD), esquemáticos electrónicos (PCB y circuitos), código fuente del software (MicroPython/C) y documentación técnica, se encuentra disponible de forma abierta en el repositorio GitHub del proyecto: \url{https://github.com/LucasZuniga/Proyecto_IRB}

\section*{Agradecimientos}
Se agradece a [COMPLETAR] por facilitar el espacio y los materiales para el desarrollo del proyecto.

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}

