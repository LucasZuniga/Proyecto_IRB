\documentclass[spanish, letterpaper, journal]{IEEEtran}
\usepackage{amsmath,amsfonts}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{url}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{fontspec}
\setmonofont{DejaVu Sans Mono}

\begin{document}

\title{Diseño y Desarrollo de Robots Educativos para Introducción a la Robótica mediante Fútbol de Robots}

\author{Allende, S., Lorca, S., Reyes, B., Román, C., Zúñiga, L.}

\maketitle

\begin{abstract}
    Este trabajo presenta el diseño y desarrollo de robots educativos orientados a la enseñanza introductoria de robótica mediante la implementación de fútbol de robots como plataforma experimental. El proyecto abarca desde la definición de las dimensiones físicas del robot hasta la construcción del circuito de control, la estructura mecánica y la programación inicial. Se propone un robot compacto (10×10 cm) que utiliza tres motores de corriente continua para su desplazamiento y control del balón, además de un solenoide para efectuar el disparo. Como innovación principal, se incorpora un rodillo de control de balón, el cual mejora significativamente la precisión y maniobrabilidad en comparación con la antigua pinza utilizada en versiones previas.
\end{abstract}

\section{Introducción}
\IEEEPARstart{L}{a} robótica educativa se ha consolidado como una herramienta pedagógica fundamental para la enseñanza de disciplinas STEM (Ciencia, Tecnología, Ingeniería y Matemáticas). Estudios previos han demostrado que los entornos competitivos, como la RoboCupJunior~\cite{robocup}, aumentan significativamente la motivación estudiantil y facilitan la adquisición de conceptos complejos en comparación con los métodos tradicionales. En el ámbito universitario, el uso de plataformas de ``fútbol de robots'' permite introducir a los estudiantes en áreas críticas como el control automático, la visión por computador (CV) y la programación en tiempo real de una manera lúdica pero rigurosa. Este proyecto se enmarca en el diseño de una herramienta de aprendizaje para un curso introductorio universitario, buscando equilibrar la complejidad técnica con la accesibilidad pedagógica.

Sin embargo, la implementación de estas plataformas en cursos masivos presenta desafíos específicos relacionados con el costo, el espacio físico y la funcionalidad mecánica. En primer lugar, las restricciones de infraestructura obligan a realizar los partidos en canchas de dimensiones reducidas, lo que impone límites estrictos al tamaño de los robots. En segundo lugar, se requiere una solución de presupuesto moderado que sea replicable para múltiples grupos de estudiantes. Finalmente, y como punto crítico identificado en iteraciones previas, los mecanismos tradicionales de manipulación de balón basados en ``pinzas'' pasivas o mecánicas han demostrado ser insuficientes. Estos mecanismos limitan severamente el control del balón durante el movimiento, dificultando la fluidez del juego y frustrando el objetivo pedagógico de enseñar estrategias de control dinámico.

Para abordar esta problemática, este trabajo presenta el diseño y desarrollo de una nueva plataforma robótica compacta y de bajo costo, optimizada para un área de juego restringida. La propuesta se distingue por tres innovaciones principales que responden directamente a las limitaciones detectadas:

\begin{itemize}
    \item \textit{Diseño Compacto y Estandarizado}: Se define una base de 10$\times$10 cm, dimensionada específicamente para garantizar maniobrabilidad en espacios reducidos sin sacrificar la capacidad de albergar componentes electrónicos esenciales.

    \item \textit{Sistema de Control de Balón Activo}: Se sustituye la antigua pinza por un mecanismo de rodillo motorizado (\textit{dribbler}). Esta innovación permite aplicar un efecto de retroceso (\textit{backspin}) al balón, mejorando drásticamente la precisión y permitiendo la retención de la pelota mientras el robot se desplaza, una técnica validada en ligas profesionales como la Small Size League~\cite{dribble}.

    \item \textit{Arquitectura Electrónica Accesible}: Se implementa el microcontrolador Raspberry Pi Pico 2 W, seleccionado por su bajo costo y capacidad de procesamiento dual-core, lo que permite gestionar la comunicación inalámbrica y los lazos de control de manera eficiente y paralela.
\end{itemize}

De esta manera, la plataforma propuesta no solo cumple con las restricciones físicas y económicas, sino que eleva el nivel técnico del curso, permitiendo a los estudiantes experimentar con conceptos avanzados de control y robótica móvil.


\section{Análisis Inicial y Restricciones de Diseño}
Antes de iniciar el desarrollo, se evaluaron las dimensiones del laboratorio y las limitaciones de los materiales disponibles. Se determinó que una base de 10x10 cm ofrecía un equilibrio adecuado entre estabilidad, maniobrabilidad y espacio para los componentes electrónicos.

\subsection{Requerimientos de diseño}
\begin{itemize}
    \item Tamaño máximo: 10x10 cm.
    \item Peso objetivo: menos de 3 kg.
    \item Componentes principales: Raspberry Pi Pico 2 W, 2 motores DC N20, 1 solenoide, 1 rodillo de control de balón.
    \item Fuente de energía: batería LiPo de 4 celdas (14.8 V).
    \item Comunicación: WiFi (preferente) y Bluetooth para interacción con múltiples dispositivos.
    \item Capacidades funcionales:
          \begin{itemize}
              \item Mantener la posesión del balón mediante un rodillo de control.
              \item Realizar el golpeo del balón mediante un solenoide.
              \item Desplazarse de manera estable sobre la cancha.
              \item Permitir control simultáneo desde múltiples dispositivos.
          \end{itemize}
\end{itemize}

\section{Diseño Mecánico}
El diseño mecánico busca un equilibrio entre simplicidad, resistencia y precisión en el control del balón.

\subsection{Estructura y materiales}
El chasis se fabrica en materiales livianos (por ejemplo, acrílico o PLA impreso en 3D), con soportes modulares para los motores, el rodillo y la electrónica. La disposición de los componentes se optimiza para mantener un centro de masa bajo y facilitar el mantenimiento.

\subsection{Sistema de locomoción}
El robot consta de dos ruedas motorizadas junto con un apoyo tipo bola, el cual proporciona un tercer punto de apoyo sin interferir en el movimiento. Las ruedas motorizadas se encuentran en la parte delantera del robot, una a cada lado. Los motores utilizados son motores DC N20 con una caja reductora de relación 1:100.

Esta disposición permite realizar movimientos lineales y giros sobre su eje mediante control diferencial. La combinación de ambos movimientos otorga al robot desplazamientos ágiles a lo largo de toda la cancha, manteniendo el control del balón durante la maniobra.

\subsection{Sistema de control de balón}
Se reemplaza la pinza mecánica del robot utilizado anteriormente por un rodillo frontal activo que permite atrapar, retener y mantener la posesión del balón de manera continua. El rodillo gira constantemente, atrayendo el balón hacia el robot y manteniéndolo en contacto, lo que facilita el control dinámico durante el desplazamiento.

La implementación de un mecanismo de dribbling activo permite aplicar efecto de retroceso (backspin) al balón, generando un efecto de ‘‘succión’’ que mejora la retención durante aceleraciones y giros, una técnica ampliamente validada en la Small Size League de la Robocup~\cite{dribble}. Esta solución presenta ventajas significativas sobre la pinza anterior: permite mantener posesión del balón mientras el robot se desplaza, aumenta la maniobrabilidad en espacios reducidos y proporciona mayor estabilidad durante movimientos complejos. El diseño del rodillo asegura que el balón permanezca bajo control incluso durante giros cerrados o cambios bruscos de dirección.

\subsection{Mecanismo de disparo}
El disparo del balón se realiza mediante un solenoide lineal que proporciona una fuerza de impacto controlada y repetible. Al activarse, el solenoide impulsa un émbolo que golpea el balón con suficiente fuerza para enviarlo a lo largo de la cancha.

El diseño incluye amortiguación para proteger los componentes electrónicos de vibraciones y prolongar la vida útil del actuador. La temporización del disparo se controla mediante el microcontrolador, permitiendo ajustar la intensidad del golpeo según la estrategia de juego.

\section{Diseño Electrónico}
El sistema electrónico se basa en un microcontrolador Raspberry Pi Pico 2 W, elegido por su bajo costo, capacidad de procesamiento dual-core, conectividad inalámbrica integrada y facilidad de programación. La arquitectura electrónica se diseñó considerando eficiencia energética, modularidad y robustez ante condiciones de operación exigentes.

\subsection{Arquitectura del Sistema}
La arquitectura electrónica del robot se organiza en cuatro subsistemas principales que interactúan de manera coordinada: la unidad de procesamiento central (MCU), la red de distribución de energía, la interfaz de control de motores dual y el circuito de actuación del solenoide. La Fig.~\ref{fig_block_diagram} presenta un diagrama de bloques de alto nivel que ilustra el flujo de datos y potencia entre estos subsistemas.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=\linewidth]{figs/block_diagram.pdf}
    \caption{Diagrama de bloques de la arquitectura electrónica. Las líneas rojas indican flujo de potencia y las azules representan flujo de datos y señales de control.}
    \label{fig_block_diagram}
\end{figure}

Como se observa en el diagrama, el sistema recibe alimentación desde una batería LiPo de 7.4V que se distribuye a través de una red regulada hacia los diferentes subsistemas. El MCU coordina todas las operaciones, procesando comandos inalámbricos (WiFi/Bluetooth), ejecutando algoritmos de control y generando señales de actuación. Los motores DC reciben señales PWM moduladas a través del driver TB6612FNG, mientras que el solenoide se activa mediante un circuito de conmutación basado en un transistor TIP102. La retroalimentación proveniente de encoders magnéticos cierra el lazo de control, permitiendo un seguimiento preciso de las velocidades de las ruedas.

\subsection{Unidad de Procesamiento Central (MCU)}
El Raspberry Pi Pico 2 W constituye el cerebro del sistema, actuando como coordinador central de todas las operaciones del robot. La selección de este microcontrolador se fundamenta en diversos criterios técnicos y pedagógicos que lo hacen adecuado para una plataforma educativa de robótica.

\textbf{Justificación de la selección:}

\textit{Facilidad de programación y versatilidad de lenguajes:}
Una de las principales ventajas del Raspberry Pi Pico 2 W es su compatibilidad con múltiples entornos de programación, específicamente MicroPython y C/C++. Esta característica resulta fundamental para el curso donde será implementado, ya que permite:
\begin{itemize}
    \item \textit{MicroPython}: ofrece una curva de aprendizaje suave para estudiantes sin experiencia en microcontroladores. Su sintaxis intuitiva y el entorno interactivo REPL facilitan la experimentación y depuración rápida.
    \item \textit{C/C++}: proporciona acceso a bajo nivel del hardware para estudiantes avanzados que requieren optimización o funcionalidades específicas, permitiendo introducir conceptos de sistemas embebidos y gestión eficiente de recursos.
\end{itemize}

Esta dualidad permite adaptar el nivel de complejidad según el progreso del estudiante sin necesidad de cambiar de plataforma.

\textit{Arquitectura dual-core para procesamiento paralelo:}
El procesador dual-core ARM Cortex-M33 a 133 MHz ofrece ventajas significativas. Como se detalla en la sección de software, esta característica permite:
\begin{itemize}
    \item Dedicación de un núcleo (Core 0) a tareas de \textbf{comunicación inalámbrica}, gestionando recepción y envío de paquetes UDP sin interferir en otras operaciones.
    \item Uso del segundo núcleo (Core 1) para el \textbf{control en tiempo real} mediante algoritmos PID, lectura de sensores y generación de señales de actuación.
    \item Garantizar determinismo temporal en el lazo de control, fundamental para la estabilidad del sistema.
\end{itemize}

Esta separación evita conflictos de recursos y asegura que la comunicación no introduzca latencias variables.

\textit{Capacidades GPIO flexibles:}
El microcontrolador ofrece 26 pines GPIO programables con soporte para:
\begin{itemize}
    \item \textit{PWM}: 16 canales independientes para control de motores y modulación del solenoide.
    \item \textit{GPIO digital}: señales de dirección, activación y lectura de encoders.
    \item \textit{I2C, SPI, UART}: expansión futura con sensores adicionales.
    \item \textit{ADC}: monitoreo de voltaje de batería u otras señales analógicas.
\end{itemize}

\textbf{Interfaz con controladores de motores:}
El MCU se comunica con el TB6612FNG mediante una interfaz digital-PWM:
\begin{itemize}
    \item Señales PWM independientes para cada motor (PWM\_A y PWM\_B), típicamente entre 20–40 kHz.
    \item Señales digitales IN1/IN2 e IN3/IN4 para dirección y frenado.
    \item Señal STBY para control de estado activo/standby.
\end{itemize}

\textbf{Especificaciones técnicas principales:}
\begin{itemize}
    \item Procesador dual-core ARM Cortex-M33 a 133 MHz.
    \item 264 KB de SRAM y 2 MB de flash.
    \item WiFi 802.11n y Bluetooth 5.2 integrados.
    \item 26 pines GPIO multifunción.
    \item Consumo menor a 1 mA en modo dormido.
    \item Rango de operación 1.8V–5.5V.
    \item Interfaz USB 1.1 para programación y depuración.
\end{itemize}

\subsection{Circuitos de Accionamiento y Control}

\textbf{Driver de Motores (TB6612FNG):}
\begin{itemize}
    \item Corriente continua: 1.2A por canal (3.2A pico).
    \item Control de dirección mediante señales digitales IN1, IN2.
    \item Control de velocidad mediante PWM.
    \item Modo de frenado activo.
    \item Protección térmica y contra sobrecorriente.
\end{itemize}

\textbf{Circuito de Actuación del Solenoide (TIP102):}
\begin{itemize}
    \item Corriente soportada: hasta 8A continua.
    \item Tensión soportada: hasta 100V.
    \item Alta ganancia de corriente ($h_{FE} > 1000$).
    \item Diodo de protección en paralelo para picos inductivos.
\end{itemize}

\subsection{Gestión de Energía}

\textbf{Fuente de Alimentación:}
Batería LiPo de 4 celdas (14.8V, 16.8V cargada) y 1500 mAh.

\textbf{Red de Distribución de Voltajes:}
\begin{itemize}
    \item 12V directo para el solenoide.
    \item 5V regulado para el TB6612FNG y motores.
    \item 3.3V regulado para el Raspberry Pi Pico 2 W.
\end{itemize}

\textbf{Protecciones:}
\begin{itemize}
    \item Diodo anti inversión.
    \item Diodo flyback en el solenoide.
    \item Switch mecánico para activación manual.
\end{itemize}

\section{Desarrollo de Software}
Dado que para el funcionamiento del proyecto debe haber un servidor y uno o más clientes, la programación se dividió en tres módulos: base/, extras/ y player/.

{\small\ttfamily
\begin{verbatim} 
software/
├── base/
│   ├── aruco_detector2.py
│   ├── servidor.py
│   └── extras/
├── player/
│   ├── control_lib.py
│   ├── WiFi.py
│   ├── main.py
│   └── extras/
└── extras/

\end{verbatim}
}

\subsection{base/}
Tal como lo indica su nombre, este módulo contiene la lógica necesaria para el correcto funcionamiento de la estacion base encargada de transmitirle los comandos al robot. Dentro de este módulo se encuentan dos archivos principales, \textit{aruco\_detector2.py} y \textit{servidor.py}.

\vspace{0.3cm}
\subsubsection{aruco\_detector2.py}
Para obtener la posición y orientación de los distintos robots en la cancha, se utilizó un sistema de \textit{ArUco markers}, dado que se trata de un método robusto que permite detectar varios marcadores a la vez con un id especifico para cada uno.

En este archivo se encuentra un diccionario con las distintas familias de marcadores, además de una clase ArUco\_Marker(), que permitirá guardar información sobre cada uno de los marcadores y dibujar en el frame de la camara información relevante para ser vista por el usuario. También se encuentra una clase ArUco\_Detector(), la cual contine ll lógica necesaria para la detección de los marcadores, ademas de guardar los marcadores detectados en una lista.

Librerias utilizadas:
\begin{itemize}
    \item cv2
    \item math
    \item numpy
\end{itemize}

\vspace{0.3cm}
\subsubsection{servidor.py}
Este es el archivo principal que se deberá correr en el computador base, para la comunicación con los robots a controlar, en este programa se aceptan las conecciones de los robots, junto con estar constantemente enviando tanto las velocidades de los motores, como el encendido y apagado del rodillo y solenoide.

El funcionamiento de código se basa en el uso de dos threads, uno que recibe las velocidades (actualmente enviadas desde el teclado, para control manual) y otro que envía las velocidades haciendo uso del protocolo UDP. La sincronización de las velocidades recibidas y enviadas se realiza mediante una variable global.

Librerias utilizadas:
\begin{itemize}
    \item socket
    \item threading
    \item time
    \item keyboard
\end{itemize}

\vspace{0.3cm}
Junto a los dos archivos principales, se tiene una carpeta llamada extras, en la cual se encuentran archivos que pueden ser utiles pero que su uso no es requerido en el loop principal del proyecto, dentro de estos archivos se encuentra uno que permite la generación de \textit{ArUco markers} entregandole la familia de marcadores y el id deseado.


\subsection{player/}
Este módulo contiene el programa que se estará ejecutando en cada uno de los robots, es decir, los códigos que se deberán cargar directamente al microcontrolador del robot. Dentro de esta carpeta se encuentran tres archivos principales, \textit{control\_lib.py}, \textit{WiFi.py} y \textit{main.py}.

\vspace{0.3cm}
\subsubsection{control\_lib.py}
Para obteer un código más légible y modular, se creo este archivo con el fin de que contenga las funciones relacionadas al control del robot. Dentro de estas funciones se encuentran la detección de los flancos de subida y de bajada de la señal recibida de los encoders, esto con el fin de obtener las rotaciones y realizar la lectura de la velocidad real de las ruedas. Además se encuentran las funciones encargadas de enviar las velocidades a los motores y al rodillo.

No se utilizaron librerias externas en este archivo.

\vspace{0.3cm}
\subsubsection{WiFi.py}
Tal como se indicó al iniccio del documento, al coneccion de cada robot con su respectiva base se realizó mediante WiFi, para permitir la conección de una base con multiples robots. Por lo anterior, en ese archivo se encuentran las funciones necesarias para iniciar una conección del robot a una red WiFi.

librerias utilizadas:
\begin{itemize}
    \item machine
    \item network
    \item rp2
    \item uasyncio
\end{itemize}

\vspace{0.3cm}
\subsubsection{main.py}

Este archivo corresponde al código principal del robot, encargado de gestionar la conexión WiFi, la comunicación con el servidor central y el control en lazo cerrado de los motores. Es el núcleo operativo del sistema, ya que coordina tanto la recepción de comandos como la ejecución de los movimientos.

El programa inicializa los pines de la Raspberry Pi Pico W, incluyendo LEDs de estado, drivers de motor, encoders y el solenoide. También configura la frecuencia de los PWM y variables globales utilizadas para el control.

A través de la función \texttt{iniciar\_cliente()}, el robot establece una conexión UDP con el servidor, envía su identificación y recibe continuamente las velocidades de referencia para ambos motores, además del estado del solenoide y del rodillo. Estos comandos se traducen en acciones sobre el hardware mediante funciones de la librería \texttt{control\_lib}.

En paralelo, mediante un hilo independiente, la función \texttt{close\_loop()} ejecuta el control de velocidad en lazo cerrado. Utilizando las lecturas de los encoders, calcula la velocidad de cada motor, estima la variación de pulsos y aplica un controlador PID para ajustar el \textit{duty cycle} del PWM. De esta forma, el robot puede seguir con precisión las velocidades indicadas por el servidor.

Finalmente, el archivo coordina la conexión WiFi mediante tareas asincrónicas que aseguran mantener el enlace activo y reactivo, mientras supervisa la comunicación y el control en tiempo real.

Librerias utilizadas:
\begin{itemize}
    \item machine
    \item network
    \item rp2
    \item socket
    \item \_thread
    \item time
    \item uasyncio
    \item control\_lib (propia)
    \item WiFi (propia)
\end{itemize}


\subsection{extras/}

En esta carpeta se incluyen diversos archivos complementarios que pueden resultar útiles para la programación del robot más allá del marco principal del proyecto. Entre ellos se encuentran dos simuladores que permiten realizar pruebas sin depender del robot físico.

El primer simulador corresponde a una base sencilla pensada para servir como punto de partida para desarrollos posteriores. En él es posible controlar dos robots utilizando únicamente el teclado: uno mediante las teclas \texttt{WASD} y el otro con \texttt{IJKL}. Su propósito principal es brindar un entorno simple donde se puedan realizar pruebas rápidas o construir nuevas funcionalidades.

El segundo simulador está orientado específicamente a la evaluación de comportamientos autónomos. En este caso, uno de los robots se controla nuevamente con las teclas \texttt{WASD}, mientras que el robot del equipo contrario recibe sus comandos desde una rutina autónoma definida por el usuario. Esto permite probar estrategias, algoritmos de movimiento y lógica de decisión sin la necesidad de utilizar el hardware real, ofreciendo una herramienta valiosa para experimentar y depurar el código de autonomía.

\subsection{Pruebas realizadas}
[COMPLETAR]

\subsection{Limitaciones observadas}
[COMPLETAR]

\section{Conclusiones y Trabajo Futuro}
El diseño presentado demuestra que es posible construir una plataforma educativa robusta, modular y escalable. La sustitución de la pinza por un rodillo mejoró considerablemente la manipulación del balón. Como trabajo futuro, se planea incorporar algoritmos de visión artificial, control autónomo y estrategias cooperativas entre múltiples robots.

\section*{Disponibilidad de Material}
Todo el material relacionado con este proyecto, incluyendo diseños mecánicos (archivos CAD), esquemáticos electrónicos (PCB y circuitos), código fuente del software (MicroPython/C) y documentación técnica, se encuentra disponible de forma abierta en el repositorio GitHub del proyecto: \url{https://github.com/LucasZuniga/Proyecto_IRB}

\section*{Agradecimientos}
Se agradece a [COMPLETAR] por facilitar el espacio y los materiales para el desarrollo del proyecto.

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
